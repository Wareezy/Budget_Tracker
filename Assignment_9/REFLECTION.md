## ðŸ”„ Reflection on Designing the Domain Model and Class Diagram

Designing the domain model and class diagram for the Minimalist Budget Tracker project was both intellectually rewarding and technically challenging. As a postgraduate student with a growing understanding of object-oriented principles, I found this task an excellent opportunity to translate abstract user and system requirements into structured, maintainable software architecture. However, the process involved several complexitiesâ€”ranging from deciding the appropriate level of abstraction to identifying meaningful relationships between classes and ensuring consistency with previously defined artifacts such as use cases and state diagrams.

One of the primary challenges I faced was determining the appropriate granularity for each domain entity. Initially, I struggled with over-modeling the systemâ€”considering separate classes for authentication sessions, login logs, and budget alerts, which made the diagram unnecessarily complex and less reusable. It took deliberate effort to consolidate concepts into more manageable and cohesive classes without losing important functionality. For example, instead of modeling alerts as a standalone class with multiple triggers, I integrated them into the **Notification** class and linked it to both **Budget** and **RecurringTransaction**, thus maintaining functional clarity while reducing complexity.

Another difficulty arose in defining the relationships between entities. While many associations were intuitive (e.g., a user having many transactions), distinguishing between simple associations, aggregations, and compositions required deeper reflection. I initially considered composition between **User** and **Budget**, reasoning that budgets were an integral part of the user experience. However, upon reviewing use case flows and state transitions, I realized that a userâ€™s existence should not determine the lifecycle of a budget. Users might archive, update, or delete budgets independently, which aligns better with aggregation.

Moreover, defining method responsibilities was challenging because I needed to abstract the system behavior without duplicating logic across classes. For instance, both **RecurringTransaction** and **Transaction** involved creation logic, but I had to delineate them clearlyâ€”assigning automatic scheduling and regeneration to the former and user-initiated entry and editing to the latter. Balancing clarity, cohesion, and minimal coupling required thoughtful iteration.

Aligning the class diagram with previous assignments, especially the use cases and state diagrams, was critical to maintaining consistency across design layers. Each class in the diagram corresponds directly to one or more functional requirements and user stories. For instance, **Transaction**, **Category**, and **Budget** directly align with use cases such as "Log Transaction", "Categorize a Transaction", and "Set a Budget." The state diagram for **Transaction** helped solidify its internal lifecycleâ€”moving from draft to logged to edited or deletedâ€”and guided my understanding of the entity's responsibilities. Likewise, **User**'s authentication process aligned with both the login activity diagram and non-functional security requirements. This traceability strengthened my confidence in the model's completeness and real-world applicability.

In terms of trade-offs, one of the major decisions was to avoid implementing inheritance hierarchies despite recognizing some structural overlap between classes like **Transaction** and **RecurringTransaction**. While inheritance could have reduced redundancy, it would have introduced complexity in maintaining specialized behaviors, especially since recurring transactions operate on a scheduled basis and follow different validation rules. Instead, I opted to keep them as separate classes, prioritizing clarity and modularity over strict object-oriented inheritance.

From this experience, I gained deeper insights into object-oriented design principles, particularly the importance of designing for maintainability and extensibility. I learned that a well-designed class diagram is not just a static representation of data but a living document that captures user behavior, system responsibilities, and design rationale. More importantly, I learned that every method, attribute, and relationship must justify its presenceâ€”not just logically, but in alignment with broader system goals.

Ultimately, this process reinforced the value of domain modeling as a foundational step in software engineering. By grounding design decisions in real-world usage and stakeholder needs, I was able to develop a domain model and class diagram that are both technically sound and user-centered. I now better appreciate the iterative and analytical nature of modeling in complex systems and feel more equipped to apply these skills in future projects or professional environments.
